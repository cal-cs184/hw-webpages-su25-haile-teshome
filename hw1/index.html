<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Summer 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Hailemariam (Haile) Teshome</div>

		<br>

		Link to webpage: (TODO) <a href="https://cal-cs184.github.io/hw-webpages-su25-haile-teshome/hw1/index.html">Webpage</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://github.com/cal-cs184/hw-webpages-su25-haile-teshome/tree/main/hw1">Repo</a>


		<h2>Overview</h2>
		The goal of this assignment was to implement a rasterizer that simulates the core functionality of a modern GPU rasterization pipeline. This project required building foundational graphics tools from scratch, with a focus on triangle rasterization, antialiasing through supersampling, color interpolation, geometric transformations, and texture mapping using various sampling techniques including mipmapping.
		Each part of the assignment focused on a different stage of the rendering pipeline. Task 1 involved triangle rasterization, where I implemented edge-function-based point-in-triangle testing within a bounding box. In Task 2, I extended this approach with supersampling to perform antialiasing by distributing multiple samples per pixel. Task 3 explored transformations by manipulating a robot SVG to animate 
		it using affine transformations. For Task 4, I implemented barycentric coordinate interpolation to blend vertex colors smoothly across triangles. In Task 5, I added support for pixel-level texture sampling, and in Task 6, I integrated level sampling with mipmaps for improved texture filtering and aliasing control.
		Through this assignment, I gained an understanding of how precision and performance tradeoffs influence rendering quality. Implementing everything from bounding box rasterization to bilinear and trilinear sampling gave me a hands-on understanding of why GPUs do what they do—and just how much computation happens behind the scenes to draw a single triangle accurately. 
		This project also taught me to think critically about performance, from loop unrolling to memoizing expensive calculations and reasoning about numerical stability when dealing with floating-point math in geometry.
			

		<h2>Task 1: Drawing Single-Color Triangles</h2>

		To rasterize single-color triangles, I implemented the rasterize_triangle() method in rasterizer.cpp. The method begins by determining the triangle’s axis-aligned bounding box, defined as the smallest rectangle that contains all three triangle vertices. This bounding box limits the pixel area that needs to be examined, reducing the computational workload compared to testing the entire frame buffer.
		For each pixel within this bounding box, I implemented a supersampling strategy where each pixel is subdivided into a grid of sub-pixel samples. The total number of samples per pixel is defined by the sample_rate. Each sample is placed at the center of its subregion and for each sample point, I calculated three edge functions corresponding to each edge of the triangle. An edge function evaluates 
		the signed area of the triangle formed by the sample point and two vertices of the triangle. If all three edge functions are non-negative (or all non-positive), the sample is inside the triangle, and I color that sample. This approach makes it so that my implementation is at least as efficient as checking every sample in the bounding box. I do not check pixels outside the bounding box, and for each 
		sample I use efficient edge function evaluations instead of more complex geometric computations. Additionally, I ensured triangle orientation by computing signed area of the triangle was negative, I swapped two vertices to enforce a consistent clockwise winding. This helps keep the edge function signs consistent and avoid false negatives when determining whether a sample is inside the triangle.
		
		<figure>
			<img src="screenshot_7-8_21-9-3.png" alt="Test4" style="width:50%"/>
			<figcaption> Screenshot of Test 4 which has 5 different single color triangles</figcaption>
		</figure>
			
		I performed several optimizations to accelerate triangle rasterization. First, I moved invariant computations outside inner loops—for example, computing edge deltas and storing them once. I also simplified the point-in-triangle test by using consistent winding and removing unnecessary computations. These optimizations yielded noticeable performance gains across several test SVGs.

			
		<table border="1" cellpadding="6" cellspacing="0">
		  <thead>
		    <tr>
		      <th>Test Case</th>
		      <th>Time Before Optimization</th>
		      <th>Time After Optimization</th>
		    </tr>
		  </thead>
		  <tbody>
		    <tr><td>basic/test3.svg</td><td>6 ms</td><td>7 ms</td></tr>
		    <tr><td>basic/test4.svg</td><td>0 ms</td><td>0 ms</td></tr>
		    <tr><td>basic/test5.svg</td><td>0 ms</td><td>1 ms</td></tr>
		    <tr><td>illustration/05_lion.svg</td><td>2 ms</td><td>3 ms</td></tr>
		    <tr><td>illustration/09_kochcurve.svg</td><td>0 ms</td><td>0 ms</td></tr>
		    <tr><td>hardcore/01_degenerate_square1.svg</td><td>31 ms</td><td>26 ms</td></tr>
		    <tr><td>hardcore/02_degenerate_square2.svg</td><td>303 ms</td><td>238 ms</td></tr>
		  </tbody>
		</table>

		Although the improvements may appear subtle for simpler scenes, they become significant in more complex inputs such as the degenerate square SVGs, where the triangle count and overlaps create a heavy rendering load.
			
		</div>

		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		This task extends the triangle rasterization to support supersampling, which is a technique for antialiasing that improves image quality by taking multiple color samples within each pixel. Instead of evaluating a single sample at the center of a pixel, supersampling will subdivides each pixel into a grid of sub-pixel samples. By averaging the results of these samples, we can reduce 
		
		aliasing artifacts like jaggies and harsh color transitions. To implement this, I modified the rasterization pipeline to use a sample_buffer instead of writing colors directly into the rgb_framebuffer_target. This buffer stores a floating-point Color value for each sub-sample, and its size is dynamically updated to be width * height * sample_rate. The number of sub-samples per 
		
		pixel is equal to sample_rate, and these sub-samples are distributed uniformly in a √N x √N grid within each pixel. In the rasterize_triangle() function, I looped over each pixel in the triangle's bounding box and then looped through each sub-sample within the pixel. Each sub-sample’s exact screen coordinate is calculated using an offset based on its position in the sub-grid (for example,
		
		x + (i + 0.5) / sqrt_rate and y + (j + 0.5) / sqrt_rate). For every sub-sample, I performed the same edge function point-in-triangle test used in Task 1 to determine whether the sample was inside the triangle. If it was, the corresponding entry in the sample_buffer was set to the triangle’s color. After rasterizing all primitives, the final pixel color is determined in resolve_to_framebuffer().
		
		For each pixel, I averaged the RGB values of all its sub-samples and wrote the result into the rgb_framebuffer_target, converting it into 8-bit integers suitable for display. This method effectively filters high-frequency aliasing artifacts by averaging over more fine-grained information, producing smoother and more natural-looking edges. 
		
		<div class="figure-row">
		  <figure>
		    <img src="1_sample.png" alt="1 sample per pixel" />
		    <figcaption>1 sample per pixel</figcaption>
		  </figure>
		  <figure>
		    <img src="2_sample.png" alt="4 samples per pixel" />
		    <figcaption>4 samples per pixel</figcaption>
		  </figure>
		  <figure>
		    <img src="3_sample.png" alt="16 samples per pixel" />
		    <figcaption>16 samples per pixel</figcaption>
		  </figure>
		</div>


		I evaluated the results by renduring basic/test4.svg with sample rates of 1, 4, and 16. At a sample rate of 1, triangle edges were clearly aliased, with noticeable stair-stepping especially on diagonals and thin shapes. At a rate of 4, edges improved significantly, showing smoother transitions and less shimmering. At 16, edges were almost perfectly smooth, with color transitions appearing continuous 
		
		even under the pixel inspector. Supersampling dramatically improves visual quality by capturing sub-pixel coverage information and especially when dealing with high-frequency detail or sharp geometry, where binary rasterization would otherwise fail to represent the smoothness of the shape. By integrating more samples per pixel, it provides a better approximation a more accurate 
		
		coverage function and mitigates the visual discontinuities caused by limited resolution.

		
		<h2>Task 3: Transforms</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 4: Barycentric coordinates</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>
